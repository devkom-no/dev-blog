<!doctype html><html lang=en-us><head><title>Cloud Sizing // devkom blog</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.104.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Eduardo Pozo"><meta name=description content><link rel=stylesheet href=https://blog.devkom.no/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Cloud Sizing"><meta name=twitter:description content="Some days ago, based on a question from a customer and as a way to &ldquo;dust off&rdquo; my python skills, i started writing a quick script/tool that fetches the assigned public ips from the major cloud providers (AWS, GCP, Azure) and converts it to other formats ready to be pushed to network infrastructure (Firewalls, ACLs, LBs, Routers, BGP injection, etc).
While doing this, and inspired from a &ldquo;100M AWS IPv4 addressess&rdquo; number, researched by Andre Toonk that i read in another blog, i got inspired to check the current status of the IPv4 usage on the cloud providers, and compare their size based on the amount of addresses assigned to their services."><meta property="og:title" content="Cloud Sizing"><meta property="og:description" content="Some days ago, based on a question from a customer and as a way to &ldquo;dust off&rdquo; my python skills, i started writing a quick script/tool that fetches the assigned public ips from the major cloud providers (AWS, GCP, Azure) and converts it to other formats ready to be pushed to network infrastructure (Firewalls, ACLs, LBs, Routers, BGP injection, etc).
While doing this, and inspired from a &ldquo;100M AWS IPv4 addressess&rdquo; number, researched by Andre Toonk that i read in another blog, i got inspired to check the current status of the IPv4 usage on the cloud providers, and compare their size based on the amount of addresses assigned to their services."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.devkom.no/posts/cloud-sizing/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-29T19:33:55+02:00"><meta property="article:modified_time" content="2022-09-29T19:33:55+02:00"></head><body><header class=app-header><a href=https://blog.devkom.no><img class=app-header-avatar src=/avatar.jpg alt="Eduardo Pozo"></a><h1>devkom blog</h1><p>A blog about network and automation</p><div class=app-header-social><a href=https://github.com/eduardopozo target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/eduardopozo target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=www.linkedin.com/in/edudppaz target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin"><title>Linedin</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Cloud Sizing</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Sep 29, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>7 min read</div></div></header><div class=post-content><p>Some days ago, based on a question from a customer and as a way to &ldquo;dust off&rdquo; my python skills, i started writing a quick script/tool that fetches the assigned public ips from the major cloud providers (AWS, GCP, Azure) and converts it to other formats ready to be pushed to network infrastructure (Firewalls, ACLs, LBs, Routers, BGP injection, etc).</p><p>While doing this, and inspired from a &ldquo;100M AWS IPv4 addressess&rdquo; number, researched by Andre Toonk that i read in another blog, i got inspired to check the current status of the IPv4 usage on the cloud providers, and compare their size based on the amount of addresses assigned to their services.</p><p>First we start with actually getting the data in. Where comes the data from? GCP and AWS very kindly provide a quick way of fetching a .json file with a simple GET that contains all their assigned IP ranges. Google does it for both &ldquo;GOOG&rdquo; (Core services) and Google Cloud (GCP). The GCP data is also divided in regions but does not contain more info. For the purpose of this simple script, this is more than enough.</p><p>GOOGLE: <a href=https://www.gstatic.com/ipranges/goog.json>https://www.gstatic.com/ipranges/goog.json</a></p><p>GCP: <a href=https://www.gstatic.com/ipranges/cloud.json>https://www.gstatic.com/ipranges/cloud.json</a></p><p>AWS: <a href=https://ip-ranges.amazonaws.com/ip-ranges.json>https://ip-ranges.amazonaws.com/ip-ranges.json</a></p><p>Azure was a little more tricky, but weÂ´ll talk about that later, lets get working on our python. In order to fetch this data programmatically and start playing with it, i created a basic GET function using the requests module that does the HTTP get and returns the json response:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>basicGET_JSON</span>(url: str) <span style=color:#f92672>-&gt;</span> dict:
</span></span><span style=display:flex><span>    retries <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(retries):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            response <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>get(url)
</span></span><span style=display:flex><span>            response<span style=color:#f92672>.</span>raise_for_status()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> HTTPError <span style=color:#66d9ef>as</span> exc:
</span></span><span style=display:flex><span>            code <span style=color:#f92672>=</span> exc<span style=color:#f92672>.</span>response<span style=color:#f92672>.</span>status_code
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> code <span style=color:#f92672>in</span> [<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>503</span>, <span style=color:#ae81ff>504</span>]:
</span></span><span style=display:flex><span>                <span style=color:#75715e># retry after n seconds</span>
</span></span><span style=display:flex><span>                time<span style=color:#f92672>.</span>sleep(n)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> response<span style=color:#f92672>.</span>json()
</span></span></code></pre></div><p>So, reusing this function, I define another one to fetch GCP and one to fetch AWS. Two functions are not actually needed, but i want some modularity as the end goal is to apply some filtering and extra functionallity for the final tool. For the sake of brevity, lets just look the GCP one, as the AWS and GOOG looks almost exactly the same <em>(ignore the &ldquo;f&rdquo; filters for now, as thats part of a later functionality that im planning)</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fetchGCP</span>(f<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;all&#34;</span>, <span style=color:#e6db74>&#34;ipv4&#34;</span>]):
</span></span><span style=display:flex><span>    GCP_URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://www.gstatic.com/ipranges/cloud.json&#34;</span>
</span></span><span style=display:flex><span>    GCP_JSON <span style=color:#f92672>=</span> basicGET_JSON(GCP_URL)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;ipv4&#34;</span> <span style=color:#f92672>in</span> f:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Going through the json and extracting all ipv4 prefixes into a list</span>
</span></span><span style=display:flex><span>        GCP_PREFIXES <span style=color:#f92672>=</span> [_<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;ipv4Prefix&#34;</span>) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> GCP_JSON[<span style=color:#e6db74>&#34;prefixes&#34;</span>]]
</span></span><span style=display:flex><span>        <span style=color:#75715e># Removing &#34;None&#34; results created by the ipv4-only query</span>
</span></span><span style=display:flex><span>        GCP_PREFIXES <span style=color:#f92672>=</span> [_ <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> GCP_PREFIXES <span style=color:#66d9ef>if</span> _ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>None</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> <span style=color:#e6db74>&#34;ipv6&#34;</span> <span style=color:#f92672>in</span> f:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Going through the json and extracting all ipv6 prefixes into a list</span>
</span></span><span style=display:flex><span>        GCP_PREFIXES <span style=color:#f92672>=</span> [_<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;ipv6Prefix&#34;</span>) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> GCP_JSON[<span style=color:#e6db74>&#34;prefixes&#34;</span>]]
</span></span><span style=display:flex><span>        <span style=color:#75715e># Removing &#34;None&#34; results created by the ipv6-only query</span>
</span></span><span style=display:flex><span>        GCP_PREFIXES <span style=color:#f92672>=</span> [_ <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> GCP_PREFIXES <span style=color:#66d9ef>if</span> _ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>None</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> GCP_PREFIXES
</span></span></code></pre></div><p>The Amazon one is actually easier as is divided on ipv4 and ipv6 prefixes, therefore there is no need to do any &ldquo;cleaning&rdquo; after filtering.</p><p>An example of the list that we get from GCP function is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> pprint<span style=color:#f92672>.</span>pprint(test)
</span></span><span style=display:flex><span>[<span style=color:#e6db74>&#39;34.80.0.0/15&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;34.137.0.0/16&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.185.128.0/19&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.185.160.0/20&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.187.144.0/20&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.189.160.0/19&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.194.128.0/17&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.201.128.0/17&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.206.192.0/18&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.220.32.0/21&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.221.128.0/17&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.229.128.0/17&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.234.0.0/18&#39;</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Now into Azure. For some unknown reason, Microsoft does not provide a direct link into their .json file, but they provide a <a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=56519">website</a> with a button that contains the actual file, but I couldnt use the direct link as the file name is updated everytime the file changes. So, for Azure, i was forced to do first a GET towards the first website, parse the response looking for the .json link, and then downloading the json.</p><p>After i have the json, i apply the same &ldquo;filtering&rdquo; as i did for Google or AWS:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fetchAzure</span>(f<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;all&#34;</span>, <span style=color:#e6db74>&#34;ipv4&#34;</span>]):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Azure download url</span>
</span></span><span style=display:flex><span>    AZURE_URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://www.microsoft.com/en-us/download/confirmation.aspx?id=56519&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the http code</span>
</span></span><span style=display:flex><span>    AZURE_HTTP <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>get(AZURE_URL)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Parse the code with regex to get the actual .json link</span>
</span></span><span style=display:flex><span>    AZURE_JSON_URL <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>search(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;https:\/\/download\.\S*\.json&#34;</span>, AZURE_HTTP<span style=color:#f92672>.</span>text
</span></span><span style=display:flex><span>    )<span style=color:#f92672>.</span>group()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Now use the json getter on the .json link</span>
</span></span><span style=display:flex><span>    AZURE_JSON <span style=color:#f92672>=</span> basicGET_JSON(AZURE_JSON_URL)
</span></span><span style=display:flex><span>    <span style=color:#75715e># The azure file has more details and is a little bit more complex, so there is a need to do more housekeeping.</span>
</span></span><span style=display:flex><span>    TEMP_PREFIXES, AZURE_PREFIXES <span style=color:#f92672>=</span> [], []
</span></span><span style=display:flex><span>    <span style=color:#75715e># Loop throguh the values</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> AZURE_JSON[<span style=color:#e6db74>&#34;values&#34;</span>]:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Make a list of the values</span>
</span></span><span style=display:flex><span>        TEMP_PREFIXES<span style=color:#f92672>.</span>extend([x <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> _[<span style=color:#e6db74>&#34;properties&#34;</span>][<span style=color:#e6db74>&#34;addressPrefixes&#34;</span>]])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> prefix <span style=color:#f92672>in</span> TEMP_PREFIXES:
</span></span><span style=display:flex><span>    <span style=color:#75715e># There is a of subnets, ipv4/v6, some without v4 and some without v6, so i need to check each string and verify if its v4 or v6</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Making it a ip_network instance</span>
</span></span><span style=display:flex><span>        address <span style=color:#f92672>=</span> ipaddress<span style=color:#f92672>.</span>ip_network(prefix)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Checking if its a valid v4</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;ipv4&#34;</span> <span style=color:#f92672>in</span> f <span style=color:#f92672>and</span> isinstance(address, ipaddress<span style=color:#f92672>.</span>IPv4Network):
</span></span><span style=display:flex><span>            AZURE_PREFIXES<span style=color:#f92672>.</span>append(prefix)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Checking if its a valid v6</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#e6db74>&#34;ipv6&#34;</span> <span style=color:#f92672>in</span> f <span style=color:#f92672>and</span> isinstance(address, ipaddress<span style=color:#f92672>.</span>IPv6Network):
</span></span><span style=display:flex><span>            AZURE_PREFIXES<span style=color:#f92672>.</span>append(prefix)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> AZURE_PREFIXES
</span></span></code></pre></div><p>Now, with the data, the rest is just math. Lets define some counters and fetch the data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>aws_count, gcp_count, goog_count, azure_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;ipv4]</span>
</span></span><span style=display:flex><span>gcp_list <span style=color:#f92672>=</span> fetchGCP(f)
</span></span><span style=display:flex><span>goog_list <span style=color:#f92672>=</span> fetchGOOG(f)
</span></span><span style=display:flex><span>aws_list <span style=color:#f92672>=</span> fetchAWS(f)
</span></span><span style=display:flex><span>azure_list <span style=color:#f92672>=</span> fetchAzure(f)
</span></span></code></pre></div><p>So now, the subnets are on lists. But we want to know the total number of ip addresses on each subnet, so lets the ipaddress python module, specifically the num_address method for the IPvXNetwork classes.</p><p>From the <a href=https://docs.python.org/3/library/ipaddress.html>documentation</a></p><pre tabindex=0><code>ipaddress provides the capabilities to create, manipulate and operate on IPv4 and IPv6 addresses and networks.&#34;

Network objects

All attributes implemented by address objects are implemented by network objects as well. In addition, network objects implement additional attributes. All of these are common between IPv4Network and IPv6Network, so to avoid duplication they are only documented for IPv4Network. Network objects are hashable, so they can be used as keys in dictionaries.

class ipaddress.IPv4Network(address, strict=True)

    Construct an IPv4 network definition. address can be one of the following:

num_addresses

    The total number of addresses in the network.
</code></pre><p>With this information, lets first define an ip_hosts function that transforms our v4 subnet string into a IPv4Network object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ip_hosts</span>(_):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ipaddress<span style=color:#f92672>.</span>IPv4Network(_)
</span></span></code></pre></div><p>Now we can loop through all the list, and update the counters with sum of all the addresses</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> gcp_list:
</span></span><span style=display:flex><span>    gcp_count <span style=color:#f92672>+=</span> ip_hosts(_)<span style=color:#f92672>.</span>num_addresses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> goog_list:
</span></span><span style=display:flex><span>    goog_count <span style=color:#f92672>+=</span> ip_hosts(_)<span style=color:#f92672>.</span>num_addresses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> aws_list:
</span></span><span style=display:flex><span>    aws_count <span style=color:#f92672>+=</span> ip_hosts(_)<span style=color:#f92672>.</span>num_addresses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> azure_list:
</span></span><span style=display:flex><span>    azure_count <span style=color:#f92672>+=</span> ip_hosts(_)<span style=color:#f92672>.</span>num_addresses
</span></span></code></pre></div><p>Now, with the counters, is just a matter of printing or doing some math with them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Number of GCP addresses: </span><span style=color:#e6db74>{</span>gcp_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Numer of GOOG addresses: </span><span style=color:#e6db74>{</span>goog_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Total GOOG (Google backbone/services + GCP): </span><span style=color:#e6db74>{</span>gcp_count <span style=color:#f92672>+</span> goog_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Total AWS addresses: </span><span style=color:#e6db74>{</span>aws_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Total Azure addresses: </span><span style=color:#e6db74>{</span>azure_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74> Total cloud: </span><span style=color:#e6db74>{</span>gcp_count <span style=color:#f92672>+</span> goog_count <span style=color:#f92672>+</span> aws_count <span style=color:#f92672>+</span> azure_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>The final result is:</p><pre tabindex=0><code>Number of GCP addresses: 11,402,496
Numer of GOOG addresses: 19,065,856
Total GOOG (Google backbone/services + GCP): 30,468,352
Total AWS addresses: 136,870,388
Total Azure addresses: 60,135,143

 Total cloud: 227,473,883
</code></pre><p>This means, that based on IPv4 usage the sizing would be: AWS>Azure>GOOG. Which is a surprise for me, as i never imagined that Azure would be &ldquo;bigger&rdquo; than Google core + GCP combined! Maybe Google is more heavy on IPv6 ?</p><p>Talking about IPv6, what are the ipv6 numbers? using the same script, and modifying the filtering, we get:</p><pre tabindex=0><code>Number of GCP addresses: 716,893,011,031,475,100,600,762,368
Numer of GOOG addresses: 1,902,094,870,361,986,792,382,504,370,176
Total GOOG (Google backbone/services + GCP): 1,902,811,763,373,018,267,483,105,132,544
Total AWS addresses: 1,217,286,314,170,012,654,257,871,781,900
Total Azure addresses: 3,156,118,579,024,291,454,408,966,192

Total cloud: 3,123,254,196,122,055,213,195,385,880,636
</code></pre><p>Which then would be Google > AWS > Azure for ipv6!</p><p>A quick search of the total public ipv4 addresses gives the number &ldquo;3,706,452,992&rdquo;. So, with some quick math, we could say that:</p><p>Total GOOG (Google backbone/services + GCP): 30,468,352 -> 0.8%
Total AWS addresses: 136,869,360 -> 3.7%
Total Azure addresses: 60,135,143 -> 1.7%</p><p>Total cloud: 227,472,855 -> 6.1%</p><p>Now, the next step is to use this data to generate configuration files for Firewalls, LBs, Routers, etc and probably push this data directly to the devices. Also, i want to apply some filtering (based on regions for example) and some extra functionality.
After i finished this quick script i also saw that it would be much better if i return some dictionaries with both ipv4 and ipv6 instead of using a filter on the fuction (as the whole data is fetched on the same GET anyways), that would improve the speed for greater datasets and give me more flexibility. But thats work for another day.</p></div><div class=post-footer></div></article></main></body></html>