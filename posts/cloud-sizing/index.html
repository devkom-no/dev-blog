<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Cloud Sizing - devkom blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Some days ago, based on a question from a customer and as a way to &ldquo;dust off&rdquo; my python skills, i started writing a quick script/tool that fetches the assigned public ips from the major cloud providers (AWS, GCP, Azure) and converts it to other formats ready to be pushed to network infrastructure (Firewalls, ACLs, LBs, Routers, BGP injection, etc).
While doing this, and inspired from a &ldquo;100M AWS IPv4 addressess&rdquo; number, researched by Andre Toonk that i read in another blog, i got inspired to check the current status of the IPv4 usage on the cloud providers, and compare their size based on the amount of addresses assigned to their services."><meta property="og:image" content><meta property="og:title" content="Cloud Sizing"><meta property="og:description" content="Some days ago, based on a question from a customer and as a way to &ldquo;dust off&rdquo; my python skills, i started writing a quick script/tool that fetches the assigned public ips from the major cloud providers (AWS, GCP, Azure) and converts it to other formats ready to be pushed to network infrastructure (Firewalls, ACLs, LBs, Routers, BGP injection, etc).
While doing this, and inspired from a &ldquo;100M AWS IPv4 addressess&rdquo; number, researched by Andre Toonk that i read in another blog, i got inspired to check the current status of the IPv4 usage on the cloud providers, and compare their size based on the amount of addresses assigned to their services."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.devkom.no/posts/cloud-sizing/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-29T19:33:55+02:00"><meta property="article:modified_time" content="2022-09-29T19:33:55+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cloud Sizing"><meta name=twitter:description content="Some days ago, based on a question from a customer and as a way to &ldquo;dust off&rdquo; my python skills, i started writing a quick script/tool that fetches the assigned public ips from the major cloud providers (AWS, GCP, Azure) and converts it to other formats ready to be pushed to network infrastructure (Firewalls, ACLs, LBs, Routers, BGP injection, etc).
While doing this, and inspired from a &ldquo;100M AWS IPv4 addressess&rdquo; number, researched by Andre Toonk that i read in another blog, i got inspired to check the current status of the IPv4 usage on the cloud providers, and compare their size based on the amount of addresses assigned to their services."><script src=https://blog.devkom.nojs/feather.min.js></script>
<link href=https://blog.devkom.no/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://blog.devkom.no/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://blog.devkom.no/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css></head><body><div class=content><header><div class=main><a href=https://blog.devkom.no>devkom blog</a></div><nav></nav></header><main><article><div class=title><h1 class=title>Cloud Sizing</h1><div class=meta>Posted on Sep 29, 2022</div></div><section class=body><p>Some days ago, based on a question from a customer and as a way to &ldquo;dust off&rdquo; my python skills, i started writing a quick script/tool that fetches the assigned public ips from the major cloud providers (AWS, GCP, Azure) and converts it to other formats ready to be pushed to network infrastructure (Firewalls, ACLs, LBs, Routers, BGP injection, etc).</p><p>While doing this, and inspired from a &ldquo;100M AWS IPv4 addressess&rdquo; number, researched by Andre Toonk that i read in another blog, i got inspired to check the current status of the IPv4 usage on the cloud providers, and compare their size based on the amount of addresses assigned to their services.</p><p>First we start with actually getting the data in. Where comes the data from? GCP and AWS very kindly provide a quick way of fetching a .json file with a simple GET that contains all their assigned IP ranges. Google does it for both &ldquo;GOOG&rdquo; (Core services) and Google Cloud (GCP). The GCP data is also divided in regions but does not contain more info. For the purpose of this simple script, this is more than enough.</p><p>GOOGLE: <a href=https://www.gstatic.com/ipranges/goog.json>https://www.gstatic.com/ipranges/goog.json</a></p><p>GCP: <a href=https://www.gstatic.com/ipranges/cloud.json>https://www.gstatic.com/ipranges/cloud.json</a></p><p>AWS: <a href=https://ip-ranges.amazonaws.com/ip-ranges.json>https://ip-ranges.amazonaws.com/ip-ranges.json</a></p><p>Azure was a little more tricky, but weÂ´ll talk about that later, lets get working on our python. In order to fetch this data programmatically and start playing with it, i created a basic GET function using the requests module that does the HTTP get and returns the json response:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>basicGET_JSON</span>(url: str) <span style=color:#f92672>-&gt;</span> dict:
</span></span><span style=display:flex><span>    retries <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(retries):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            response <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>get(url)
</span></span><span style=display:flex><span>            response<span style=color:#f92672>.</span>raise_for_status()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> HTTPError <span style=color:#66d9ef>as</span> exc:
</span></span><span style=display:flex><span>            code <span style=color:#f92672>=</span> exc<span style=color:#f92672>.</span>response<span style=color:#f92672>.</span>status_code
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> code <span style=color:#f92672>in</span> [<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>503</span>, <span style=color:#ae81ff>504</span>]:
</span></span><span style=display:flex><span>                <span style=color:#75715e># retry after n seconds</span>
</span></span><span style=display:flex><span>                time<span style=color:#f92672>.</span>sleep(n)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> response<span style=color:#f92672>.</span>json()
</span></span></code></pre></div><p>So, reusing this function, I define another one to fetch GCP and one to fetch AWS. Two functions are not actually needed, but i want some modularity as the end goal is to apply some filtering and extra functionallity for the final tool. For the sake of brevity, lets just look the GCP one, as the AWS and GOOG looks almost exactly the same <em>(ignore the &ldquo;f&rdquo; filters for now, as thats part of a later functionality that im planning)</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fetchGCP</span>(f<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;all&#34;</span>, <span style=color:#e6db74>&#34;ipv4&#34;</span>]):
</span></span><span style=display:flex><span>    GCP_URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://www.gstatic.com/ipranges/cloud.json&#34;</span>
</span></span><span style=display:flex><span>    GCP_JSON <span style=color:#f92672>=</span> basicGET_JSON(GCP_URL)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;ipv4&#34;</span> <span style=color:#f92672>in</span> f:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Going through the json and extracting all ipv4 prefixes into a list</span>
</span></span><span style=display:flex><span>        GCP_PREFIXES <span style=color:#f92672>=</span> [_<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;ipv4Prefix&#34;</span>) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> GCP_JSON[<span style=color:#e6db74>&#34;prefixes&#34;</span>]]
</span></span><span style=display:flex><span>        <span style=color:#75715e># Removing &#34;None&#34; results created by the ipv4-only query</span>
</span></span><span style=display:flex><span>        GCP_PREFIXES <span style=color:#f92672>=</span> [_ <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> GCP_PREFIXES <span style=color:#66d9ef>if</span> _ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>None</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> <span style=color:#e6db74>&#34;ipv6&#34;</span> <span style=color:#f92672>in</span> f:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Going through the json and extracting all ipv6 prefixes into a list</span>
</span></span><span style=display:flex><span>        GCP_PREFIXES <span style=color:#f92672>=</span> [_<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;ipv6Prefix&#34;</span>) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> GCP_JSON[<span style=color:#e6db74>&#34;prefixes&#34;</span>]]
</span></span><span style=display:flex><span>        <span style=color:#75715e># Removing &#34;None&#34; results created by the ipv6-only query</span>
</span></span><span style=display:flex><span>        GCP_PREFIXES <span style=color:#f92672>=</span> [_ <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> GCP_PREFIXES <span style=color:#66d9ef>if</span> _ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>None</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> GCP_PREFIXES
</span></span></code></pre></div><p>The Amazon one is actually easier as is divided on ipv4 and ipv6 prefixes, therefore there is no need to do any &ldquo;cleaning&rdquo; after filtering.</p><p>An example of the list that we get from GCP function is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> pprint<span style=color:#f92672>.</span>pprint(test)
</span></span><span style=display:flex><span>[<span style=color:#e6db74>&#39;34.80.0.0/15&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;34.137.0.0/16&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.185.128.0/19&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.185.160.0/20&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.187.144.0/20&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.189.160.0/19&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.194.128.0/17&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.201.128.0/17&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.206.192.0/18&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.220.32.0/21&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.221.128.0/17&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.229.128.0/17&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;35.234.0.0/18&#39;</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Now into Azure. For some unknown reason, Microsoft does not provide a direct link into their .json file, but they provide a <a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=56519">website</a> with a button that contains the actual file, but I couldnt use the direct link as the file name is updated everytime the file changes. So, for Azure, i was forced to do first a GET towards the first website, parse the response looking for the .json link, and then downloading the json.</p><p>After i have the json, i apply the same &ldquo;filtering&rdquo; as i did for Google or AWS:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fetchAzure</span>(f<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;all&#34;</span>, <span style=color:#e6db74>&#34;ipv4&#34;</span>]):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Azure download url</span>
</span></span><span style=display:flex><span>    AZURE_URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://www.microsoft.com/en-us/download/confirmation.aspx?id=56519&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the http code</span>
</span></span><span style=display:flex><span>    AZURE_HTTP <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>get(AZURE_URL)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Parse the code with regex to get the actual .json link</span>
</span></span><span style=display:flex><span>    AZURE_JSON_URL <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>search(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;https:\/\/download\.\S*\.json&#34;</span>, AZURE_HTTP<span style=color:#f92672>.</span>text
</span></span><span style=display:flex><span>    )<span style=color:#f92672>.</span>group()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Now use the json getter on the .json link</span>
</span></span><span style=display:flex><span>    AZURE_JSON <span style=color:#f92672>=</span> basicGET_JSON(AZURE_JSON_URL)
</span></span><span style=display:flex><span>    <span style=color:#75715e># The azure file has more details and is a little bit more complex, so there is a need to do more housekeeping.</span>
</span></span><span style=display:flex><span>    TEMP_PREFIXES, AZURE_PREFIXES <span style=color:#f92672>=</span> [], []
</span></span><span style=display:flex><span>    <span style=color:#75715e># Loop throguh the values</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> AZURE_JSON[<span style=color:#e6db74>&#34;values&#34;</span>]:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Make a list of the values</span>
</span></span><span style=display:flex><span>        TEMP_PREFIXES<span style=color:#f92672>.</span>extend([x <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> _[<span style=color:#e6db74>&#34;properties&#34;</span>][<span style=color:#e6db74>&#34;addressPrefixes&#34;</span>]])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> prefix <span style=color:#f92672>in</span> TEMP_PREFIXES:
</span></span><span style=display:flex><span>    <span style=color:#75715e># There is a of subnets, ipv4/v6, some without v4 and some without v6, so i need to check each string and verify if its v4 or v6</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Making it a ip_network instance</span>
</span></span><span style=display:flex><span>        address <span style=color:#f92672>=</span> ipaddress<span style=color:#f92672>.</span>ip_network(prefix)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Checking if its a valid v4</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;ipv4&#34;</span> <span style=color:#f92672>in</span> f <span style=color:#f92672>and</span> isinstance(address, ipaddress<span style=color:#f92672>.</span>IPv4Network):
</span></span><span style=display:flex><span>            AZURE_PREFIXES<span style=color:#f92672>.</span>append(prefix)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Checking if its a valid v6</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#e6db74>&#34;ipv6&#34;</span> <span style=color:#f92672>in</span> f <span style=color:#f92672>and</span> isinstance(address, ipaddress<span style=color:#f92672>.</span>IPv6Network):
</span></span><span style=display:flex><span>            AZURE_PREFIXES<span style=color:#f92672>.</span>append(prefix)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> AZURE_PREFIXES
</span></span></code></pre></div><p>Now, with the data, the rest is just math. Lets define some counters and fetch the data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>aws_count, gcp_count, goog_count, azure_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;ipv4]</span>
</span></span><span style=display:flex><span>gcp_list <span style=color:#f92672>=</span> fetchGCP(f)
</span></span><span style=display:flex><span>goog_list <span style=color:#f92672>=</span> fetchGOOG(f)
</span></span><span style=display:flex><span>aws_list <span style=color:#f92672>=</span> fetchAWS(f)
</span></span><span style=display:flex><span>azure_list <span style=color:#f92672>=</span> fetchAzure(f)
</span></span></code></pre></div><p>So now, the subnets are on lists. But we want to know the total number of ip addresses on each subnet, so lets use the ipaddress python module, specifically the num_address method for the IPv(4/6)Network classes.</p><p>From the <a href=https://docs.python.org/3/library/ipaddress.html>documentation</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ipaddress provides the capabilities to create, manipulate and operate on IPv4 and IPv6 addresses and networks.&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Network objects
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>All attributes implemented by address objects are implemented by network objects as well. In addition, network objects implement additional attributes. All of these are common between IPv4Network and IPv6Network, so to avoid duplication they are only documented for IPv4Network. Network objects are hashable, so they can be used as keys in dictionaries.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class ipaddress.IPv4Network(address, strict=True)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Construct an IPv4 network definition. address can be one of the following:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num_addresses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    The total number of addresses in the network.
</span></span></code></pre></div><p>With this information, lets first define an ip_hosts function that transforms our v4 subnet string into a IPv4Network object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ip_hosts</span>(_):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ipaddress<span style=color:#f92672>.</span>IPv4Network(_)
</span></span></code></pre></div><p>Now we can loop through all the list, and update the counters with sum of all the addresses</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> gcp_list:
</span></span><span style=display:flex><span>    gcp_count <span style=color:#f92672>+=</span> ip_hosts(_)<span style=color:#f92672>.</span>num_addresses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> goog_list:
</span></span><span style=display:flex><span>    goog_count <span style=color:#f92672>+=</span> ip_hosts(_)<span style=color:#f92672>.</span>num_addresses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> aws_list:
</span></span><span style=display:flex><span>    aws_count <span style=color:#f92672>+=</span> ip_hosts(_)<span style=color:#f92672>.</span>num_addresses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> azure_list:
</span></span><span style=display:flex><span>    azure_count <span style=color:#f92672>+=</span> ip_hosts(_)<span style=color:#f92672>.</span>num_addresses
</span></span></code></pre></div><p>Now, with the counters, is just a matter of printing or doing some math with them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Number of GCP addresses: </span><span style=color:#e6db74>{</span>gcp_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Numer of GOOG addresses: </span><span style=color:#e6db74>{</span>goog_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Total GOOG (Google backbone/services + GCP): </span><span style=color:#e6db74>{</span>gcp_count <span style=color:#f92672>+</span> goog_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Total AWS addresses: </span><span style=color:#e6db74>{</span>aws_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Total Azure addresses: </span><span style=color:#e6db74>{</span>azure_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74> Total cloud: </span><span style=color:#e6db74>{</span>gcp_count <span style=color:#f92672>+</span> goog_count <span style=color:#f92672>+</span> aws_count <span style=color:#f92672>+</span> azure_count<span style=color:#e6db74>:</span><span style=color:#e6db74>,</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>The final result is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Number of GCP addresses: 11,402,496
</span></span><span style=display:flex><span>Numer of GOOG addresses: 19,065,856
</span></span><span style=display:flex><span>Total GOOG (Google backbone/services + GCP): 30,468,352
</span></span><span style=display:flex><span>Total AWS addresses: 136,870,388
</span></span><span style=display:flex><span>Total Azure addresses: 60,135,143
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> Total cloud: 227,473,883
</span></span></code></pre></div><p>This means, that based on IPv4 usage the sizing would be: AWS>Azure>GOOG. Which is a surprise for me, as i neverimagined that Azure would be &ldquo;bigger&rdquo; than Google core + GCP combined! Maybe Google is more heavy on IPv6 ?
Using the same script, and modifying the filtering, we get:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Number of GCP addresses: 716,893,011,031,475,100,600,762,368
</span></span><span style=display:flex><span>Numer of GOOG addresses: 1,902,094,870,361,986,792,382,504,370,176
</span></span><span style=display:flex><span>Total GOOG (Google backbone/services + GCP): 1,902,811,763,373,018,267,483,105,132,544
</span></span><span style=display:flex><span>Total AWS addresses: 1,217,286,314,170,012,654,257,871,781,900
</span></span><span style=display:flex><span>Total Azure addresses: 3,156,118,579,024,291,454,408,966,192
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Total cloud: 3,123,254,196,122,055,213,195,385,880,636
</span></span></code></pre></div><p>Which then would be Google > AWS > Azure for ipv6!</p><p>A quick search of the total public ipv4 addresses gives the number &ldquo;3,706,452,992&rdquo;. So, with some quick math, we could say that:</p><p>Total GOOG (Google backbone/services + GCP): 30,468,352 -> 0.8%
Total AWS addresses: 136,869,360 -> 3.7%
Total Azure addresses: 60,135,143 -> 1.7%</p><p>Total cloud: 227,472,855 -> 6.1%</p><p>Now, the next step is to use this data to generate configuration files for Firewalls, LBs, Routers, etc and probably push this data directly to the devices. Also, i want to apply some filtering (based on regions for example) and some extra functionality.
After i finished this quick script i also saw that it would be much better if i return some dictionaries with both ipv4 and ipv6 instead of using a filter on the fuction (as the whole data is fetched on the same GET anyways), that would improve the speed for greater datasets and give me more flexibility. But thats work for another day.</p></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/eduardopozo title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/eduardopozo title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=https://linkedin.com/in/edudppaz title=Linedin><i data-feather=linkedin></i></a>
<a class=border></a></div><div class=footer-info>2022 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>